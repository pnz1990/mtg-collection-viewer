<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deck Checker - MTG Collection Viewer</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>MTG Collection Viewer</h1>
    <div class="stats">
      <span>Deck Checker</span>
      <select id="theme-select" class="theme-select">
        <option value="">Dark (Default)</option>
        <option value="azorius">Azorius</option>
        <option value="dimir">Dimir</option>
        <option value="rakdos">Rakdos</option>
        <option value="gruul">Gruul</option>
        <option value="selesnya">Selesnya</option>
        <option value="orzhov">Orzhov</option>
        <option value="izzet">Izzet</option>
        <option value="golgari">Golgari</option>
        <option value="boros">Boros</option>
        <option value="simic">Simic</option>
      </select>
    </div>
  </header>

  <div class="deck-checker">
    <div class="deck-input">
      <h2>Check Deck Against Your Collection</h2>
      <p>Paste your deck list below (format: 1 Card Name)</p>
      <textarea id="deck-list" placeholder="1 Sol Ring&#10;1 Command Tower&#10;1 Lightning Bolt&#10;4 Counterspell&#10;..." class="deck-list-input"></textarea>
      <button type="button" id="check-list" class="check-btn">Check Deck</button>
    </div>
    
    <div id="deck-results" class="deck-results hidden">
      <div class="results-summary">
        <div class="summary-owned">
          <span class="summary-count" id="owned-count">0</span>
          <span class="summary-label">Cards You Own</span>
        </div>
        <div class="summary-missing">
          <span class="summary-count" id="missing-count">0</span>
          <span class="summary-label">Cards Missing</span>
        </div>
        <div class="summary-percent">
          <span class="summary-count" id="owned-percent">0%</span>
          <span class="summary-label">Complete</span>
        </div>
      </div>
      
      <div class="results-columns">
        <div class="results-column owned">
          <h3>‚úì Cards You Own</h3>
          <div id="owned-list" class="card-grid"></div>
        </div>
        <div class="results-column missing">
          <h3>‚úó Cards Missing</h3>
          <div id="missing-list" class="card-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <a href="index.html" class="back-link">‚Üê Back to Collection</a>

  <script>
    // Theme switcher
    const themeSelect = document.getElementById('theme-select');
    const savedTheme = localStorage.getItem('mtg-theme') || '';
    document.documentElement.dataset.theme = savedTheme;
    themeSelect.value = savedTheme;
    themeSelect.addEventListener('change', () => {
      document.documentElement.dataset.theme = themeSelect.value;
      localStorage.setItem('mtg-theme', themeSelect.value);
    });

    let collectionNames = new Map(); // name -> { scryfallId, type_line }
    let db;

    // IndexedDB for cached card data
    const dbPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open('mtg-images', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => { db = request.result; resolve(db); };
      request.onupgradeneeded = e => {
        e.target.result.createObjectStore('images', { keyPath: 'id' });
      };
    });

    async function getCardData(scryfallId) {
      await dbPromise;
      return new Promise(resolve => {
        const tx = db.transaction('images', 'readonly');
        const req = tx.objectStore('images').get(`card_${scryfallId}`);
        req.onsuccess = () => resolve(req.result?.data);
        req.onerror = () => resolve(null);
      });
    }

    async function loadCollection() {
      const response = await fetch('Collection.csv');
      const text = await response.text();
      const lines = text.split('\n').slice(1);
      
      for (const line of lines) {
        if (!line.trim()) continue;
        const parts = line.split(',');
        const name = parts[0].replace(/^"|"$/g, '').toLowerCase();
        const scryfallId = parts[8]?.replace(/^"|"$/g, '');
        if (!collectionNames.has(name) && scryfallId) {
          const cached = await getCardData(scryfallId);
          collectionNames.set(name, { scryfallId, type_line: cached?.type_line || '' });
        }
      });
    }

    function parseDeckList(text) {
      const cards = new Set();
      const lines = text.trim().split('\n');
      
      for (const line of lines) {
        let trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('#')) continue;
        
        // Remove quantity prefix (e.g., "1 " or "4x ")
        trimmed = trimmed.replace(/^\d+x?\s+/, '');
        // Remove set info (anything after "(")
        const name = trimmed.split('(')[0].trim();
        if (name) cards.add(name.toLowerCase());
      }
      return [...cards].map(name => ({ name }));
    }

    function checkDeck(deckCards) {
      const owned = [];
      const missing = [];
      
      for (const card of deckCards) {
        if (collectionNames.has(card.name)) {
          const data = collectionNames.get(card.name);
          owned.push({ ...card, scryfallId: data.scryfallId, type_line: data.type_line });
        } else {
          missing.push(card);
        }
      }
      
      return { owned, missing };
    }

    async function fetchCardImage(name) {
      try {
        const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`);
        if (!response.ok) return null;
        const data = await response.json();
        return data.image_uris?.small || data.card_faces?.[0]?.image_uris?.small;
      } catch (e) {
        return null;
      }
    }

    async function displayResults(owned, missing) {
      const results = document.getElementById('deck-results');
      results.classList.remove('hidden');
      
      const totalCards = owned.length + missing.length;
      const percent = totalCards > 0 ? Math.round((owned.length / totalCards) * 100) : 0;
      
      document.getElementById('owned-count').textContent = owned.length;
      document.getElementById('missing-count').textContent = missing.length;
      document.getElementById('owned-percent').textContent = percent + '%';
      
      const ownedList = document.getElementById('owned-list');
      const missingList = document.getElementById('missing-list');
      
      const getType = (typeLine) => {
        if (!typeLine) return 'Other';
        return ['Creature', 'Instant', 'Sorcery', 'Artifact', 'Enchantment', 'Land', 'Planeswalker']
          .find(t => typeLine.includes(t)) || 'Other';
      };
      
      const renderCard = (c, isOwned) => `
        <div class="deck-card-tile ${isOwned ? 'owned' : 'missing'}" data-name="${c.name}">
          <img src="${isOwned ? `https://cards.scryfall.io/small/front/${c.scryfallId[0]}/${c.scryfallId[1]}/${c.scryfallId}.jpg` : 'back.png'}" 
               alt="${c.name}" onerror="this.src='back.png'">
          ${c.type_line ? `<div class="tile-type">${getType(c.type_line)}</div>` : ''}
          ${!isOwned ? `<div class="tile-name">${c.name}</div>` : ''}
        </div>
      `;
      
      ownedList.innerHTML = owned.map(c => renderCard(c, true)).join('') || '<div class="empty">No cards owned</div>';
      missingList.innerHTML = missing.map(c => renderCard(c, false)).join('') || '<div class="empty">You own all cards! üéâ</div>';
      
      // Load missing card images and types from Scryfall
      for (const card of missing) {
        const tile = missingList.querySelector(`[data-name="${CSS.escape(card.name)}"]`);
        if (tile) {
          try {
            const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(card.name)}`);
            if (response.ok) {
              const data = await response.json();
              const url = data.image_uris?.small || data.card_faces?.[0]?.image_uris?.small;
              if (url) tile.querySelector('img').src = url;
              const type = getType(data.type_line);
              tile.insertAdjacentHTML('beforeend', `<div class="tile-type">${type}</div>`);
            }
          } catch (e) {}
        }
      }
    }

    document.getElementById('check-list').addEventListener('click', () => {
      const text = document.getElementById('deck-list').value.trim();
      if (!text) return;
      
      const deckCards = parseDeckList(text);
      const { owned, missing } = checkDeck(deckCards);
      displayResults(owned, missing);
    });

    loadCollection();
  </script>
</body>
</html>
