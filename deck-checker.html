<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Deck Checker - MTG Collection Viewer</title>
  <link rel="icon" href="images/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="nav-menu">
    <button type="button" class="menu-toggle" id="menu-toggle">‚ò∞</button>
    <div class="menu-overlay" id="menu-overlay"></div>
    <div class="menu-dropdown" id="menu-dropdown">
      <div class="menu-header">MTG Collection</div>
      <div class="menu-section">
        <div class="menu-section-title">Views</div>
        <a href="index.html" class="menu-item">‚äû Collection Explorer</a>
        <a href="binder.html" class="menu-item">üìñ Binder View</a>
        <a href="carousel.html" class="menu-item">üé† Carousel View</a>
        <a href="timeline.html" class="menu-item">üìÖ Timeline View</a>
      </div>
      <div class="menu-section">
        <div class="menu-section-title">Tools</div>
        <a href="deck-checker.html" class="menu-item active">üîç Deck Checker</a>
        <a href="trade-calculator.html" class="menu-item">‚öñÔ∏è Trade Calculator</a>
        <a href="trivia.html" class="menu-item">üéØ Collection Trivia</a>
        <a href="guess-card.html" class="menu-item">üé¥ Guess the Card</a>
        <a href="game-tracker.html" class="menu-item">üéÆ Game Tracker</a>
      </div>
      <div class="menu-section">
        <div class="menu-section-title">Theme</div>
        <select id="theme-select" class="menu-theme-select">
          <option value="">Dark (Default)</option>
          <option value="azorius">Azorius</option>
          <option value="dimir">Dimir</option>
          <option value="rakdos">Rakdos</option>
          <option value="gruul">Gruul</option>
          <option value="selesnya">Selesnya</option>
          <option value="orzhov">Orzhov</option>
          <option value="izzet">Izzet</option>
          <option value="golgari">Golgari</option>
          <option value="boros">Boros</option>
          <option value="simic">Simic</option>
        </select>
      </div>
    </div>
  </div>

  <header>
    <h1>MTG Collection Viewer</h1>
    <div class="stats">
      <span>Deck Checker</span>
    </div>
  </header>

  <div class="deck-checker">
    <div class="deck-input">
      <h2>Check Deck Against Your Collection</h2>
      <p>Paste your deck list below (format: 1 Card Name)</p>
      <textarea id="deck-list" placeholder="1 Sol Ring&#10;1 Command Tower&#10;1 Lightning Bolt&#10;4 Counterspell&#10;..." class="deck-list-input"></textarea>
      <button type="button" id="check-list" class="check-btn">Check Deck</button>
    </div>
    
    <div id="deck-results" class="deck-results hidden">
      <div class="results-summary">
        <div class="summary-owned">
          <span class="summary-count" id="owned-count">0</span>
          <span class="summary-label">Cards You Own</span>
        </div>
        <div class="summary-missing">
          <span class="summary-count" id="missing-count">0</span>
          <span class="summary-label">Cards Missing</span>
        </div>
        <div class="summary-percent">
          <span class="summary-count" id="owned-percent">0%</span>
          <span class="summary-label">Complete</span>
        </div>
      </div>
      
      <button type="button" id="convert-deck" class="convert-btn">Convert to Owned Versions</button>
      
      <div class="results-columns">
        <div class="results-column owned">
          <h3>‚úì Cards You Own</h3>
          <div id="owned-list" class="card-grid"></div>
        </div>
        <div class="results-column missing">
          <h3>‚úó Cards Missing</h3>
          <div id="missing-list" class="card-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <a href="index.html" class="back-link">‚Üê Back to Collection</a>

  <script>
    // Menu toggle (runs immediately since script is at end of body)
    const menuToggle = document.getElementById('menu-toggle');
    const menuDropdown = document.getElementById('menu-dropdown');
    const menuOverlay = document.getElementById('menu-overlay');
    menuToggle.addEventListener('click', () => {
      menuDropdown.classList.toggle('show');
      menuOverlay.classList.toggle('show');
    });
    menuOverlay.addEventListener('click', () => {
      menuDropdown.classList.remove('show');
      menuOverlay.classList.remove('show');
    });

    // Theme switcher
    const themeSelect = document.getElementById('theme-select');
    const savedTheme = localStorage.getItem('mtg-theme') || '';
    document.documentElement.dataset.theme = savedTheme;
    themeSelect.value = savedTheme;
    themeSelect.addEventListener('change', () => {
      document.documentElement.dataset.theme = themeSelect.value;
      localStorage.setItem('mtg-theme', themeSelect.value);
    });

    let collectionNames = new Map(); // name -> { scryfallId, type_line }
    let collectionCards = new Map(); // name -> array of card versions
    let currentDeckList = [];
    let currentOwnedCards = [];
    let currentMissingCards = [];
    let db;

    // IndexedDB for cached card data
    const dbPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open('mtg-images', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => { db = request.result; resolve(db); };
      request.onupgradeneeded = e => {
        e.target.result.createObjectStore('images', { keyPath: 'id' });
      };
    });

    async function getCardData(scryfallId) {
      await dbPromise;
      return new Promise(resolve => {
        const tx = db.transaction('images', 'readonly');
        const req = tx.objectStore('images').get(`card_${scryfallId}`);
        req.onsuccess = () => resolve(req.result?.data);
        req.onerror = () => resolve(null);
      });
    }

    async function loadCollection() {
      const response = await fetch('data/Collection.csv');
      const text = await response.text();
      const lines = text.split('\n').slice(1);
      
      for (const line of lines) {
        if (!line.trim()) continue;
        const parts = parseCSVLine(line);
        const name = parts[0].toLowerCase();
        const setCode = parts[1];
        const collectorNumber = parts[3];
        const foil = parts[4];
        const scryfallId = parts[8];
        
        if (!scryfallId) continue;
        
        const cached = await getCardData(scryfallId);
        const cardVersion = {
          scryfallId,
          setCode,
          collectorNumber,
          foil,
          type_line: cached?.type_line || '',
          setName: parts[2]
        };
        
        if (!collectionNames.has(name)) {
          collectionNames.set(name, cardVersion);
        }
        
        if (!collectionCards.has(name)) {
          collectionCards.set(name, []);
        }
        collectionCards.get(name).push(cardVersion);
      }
    }
    
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (const char of line) {
        if (char === '"') inQuotes = !inQuotes;
        else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
        else current += char;
      }
      result.push(current);
      return result;
    }

    function parseDeckList(text) {
      const cards = [];
      const lines = text.trim().split('\n');
      
      for (const line of lines) {
        let trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('#')) continue;
        
        // Extract quantity
        const match = trimmed.match(/^(\d+)x?\s+(.+)/);
        const quantity = match ? parseInt(match[1]) : 1;
        const rest = match ? match[2] : trimmed;
        
        // Remove set info (anything after "(")
        let name = rest.split('(')[0].trim();
        
        // Normalize double-faced cards: single slash -> double slash
        name = name.replace(/\s\/\s/g, ' // ');
        
        if (name) cards.push({ name: name.toLowerCase(), quantity });
      }
      return cards;
    }

    async function checkDeck(deckCards) {
      const owned = [];
      const missing = [];
      const toCheckScryfall = [];
      
      // First pass: exact name matches
      for (const card of deckCards) {
        if (collectionNames.has(card.name)) {
          const data = collectionNames.get(card.name);
          owned.push({ ...card, scryfallId: data.scryfallId, type_line: data.type_line });
        } else {
          toCheckScryfall.push(card);
        }
      }
      
      // Second pass: check Scryfall for alternate names (flavor names)
      for (const card of toCheckScryfall) {
        const alternateMatch = await checkAlternateNames(card.name);
        if (alternateMatch) {
          owned.push({ ...card, scryfallId: alternateMatch.scryfallId, type_line: alternateMatch.type_line });
        } else {
          missing.push(card);
        }
      }
      
      return { owned, missing };
    }

    async function checkAlternateNames(cardName) {
      try {
        // Fetch card from Scryfall to get all printings
        const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
        if (!response.ok) return null;
        const card = await response.json();
        
        // Get all possible names for this card
        const namesToCheck = [card.name.toLowerCase()];
        if (card.flavor_name) namesToCheck.push(card.flavor_name.toLowerCase());
        
        // Check if we own any version with any of these names
        for (const name of namesToCheck) {
          if (collectionNames.has(name)) {
            return collectionNames.get(name);
          }
        }
        
        // Check all printings for flavor names
        const printingsResponse = await fetch(`https://api.scryfall.com/cards/search?q=!"${encodeURIComponent(card.name)}"&unique=prints`);
        if (printingsResponse.ok) {
          const printings = await printingsResponse.json();
          for (const printing of printings.data) {
            if (printing.flavor_name) {
              const flavorName = printing.flavor_name.toLowerCase();
              if (collectionNames.has(flavorName)) {
                return collectionNames.get(flavorName);
              }
            }
          }
        }
        
        return null;
      } catch (e) {
        console.error('Error checking alternate names:', e);
        return null;
      }
    }

    async function fetchCardImage(name) {
      try {
        const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`);
        if (!response.ok) return null;
        const data = await response.json();
        return data.image_uris?.small || data.card_faces?.[0]?.image_uris?.small;
      } catch (e) {
        return null;
      }
    }

    async function displayResults(owned, missing) {
      const results = document.getElementById('deck-results');
      results.classList.remove('hidden');
      
      const totalCards = owned.length + missing.length;
      const percent = totalCards > 0 ? Math.round((owned.length / totalCards) * 100) : 0;
      
      document.getElementById('owned-count').textContent = owned.length;
      document.getElementById('missing-count').textContent = missing.length;
      document.getElementById('owned-percent').textContent = percent + '%';
      
      const ownedList = document.getElementById('owned-list');
      const missingList = document.getElementById('missing-list');
      
      const getType = (typeLine) => {
        if (!typeLine) return 'Other';
        return ['Creature', 'Instant', 'Sorcery', 'Artifact', 'Enchantment', 'Land', 'Planeswalker']
          .find(t => typeLine.includes(t)) || 'Other';
      };
      
      const renderCard = (c, isOwned) => `
        <div class="deck-card-tile ${isOwned ? 'owned' : 'missing'}" data-name="${c.name}">
          <img src="${isOwned ? `https://cards.scryfall.io/small/front/${c.scryfallId[0]}/${c.scryfallId[1]}/${c.scryfallId}.jpg` : 'back.png'}" 
               alt="${c.name}" onerror="this.src='back.png'">
          ${c.type_line ? `<div class="tile-type">${getType(c.type_line)}</div>` : ''}
          ${!isOwned ? `<div class="tile-name">${c.name}</div>` : ''}
        </div>
      `;
      
      ownedList.innerHTML = owned.map(c => renderCard(c, true)).join('') || '<div class="empty">No cards owned</div>';
      missingList.innerHTML = missing.map(c => renderCard(c, false)).join('') || '<div class="empty">You own all cards! üéâ</div>';
      
      // Load missing card images in parallel (batch of 10)
      const loadMissingImages = async () => {
        const batchSize = 10;
        for (let i = 0; i < missing.length; i += batchSize) {
          const batch = missing.slice(i, i + batchSize);
          await Promise.all(batch.map(async card => {
            const tile = missingList.querySelector(`[data-name="${CSS.escape(card.name)}"]`);
            if (!tile) return;
            try {
              const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(card.name)}`);
              if (response.ok) {
                const data = await response.json();
                const url = data.image_uris?.small || data.card_faces?.[0]?.image_uris?.small;
                if (url) tile.querySelector('img').src = url;
                const type = getType(data.type_line);
                if (!tile.querySelector('.tile-type')) {
                  tile.insertAdjacentHTML('beforeend', `<div class="tile-type">${type}</div>`);
                }
              }
            } catch (e) {}
          }));
          if (i + batchSize < missing.length) await new Promise(r => setTimeout(r, 100));
        }
      };
      loadMissingImages();
    }

    document.getElementById('check-list').addEventListener('click', async () => {
      const text = document.getElementById('deck-list').value.trim();
      if (!text) return;
      
      const btn = document.getElementById('check-list');
      const originalText = btn.textContent;
      btn.textContent = 'Checking...';
      btn.disabled = true;
      
      try {
        currentDeckList = parseDeckList(text);
        const { owned, missing } = await checkDeck(currentDeckList);
        currentOwnedCards = owned;
        currentMissingCards = missing;
        await displayResults(owned, missing);
      } finally {
        btn.textContent = originalText;
        btn.disabled = false;
      }
    });

    document.getElementById('convert-deck').addEventListener('click', async () => {
      await convertDeck();
    });

    async function convertDeck() {
      const selectedVersions = new Map();
      const multipleVersions = [];
      
      // Check which cards have multiple versions (including alternate names)
      for (const card of currentDeckList) {
        const allVersions = await getAllVersionsForCard(card.name);
        
        if (allVersions.length > 1) {
          multipleVersions.push({ ...card, versions: allVersions });
        } else if (allVersions.length === 1) {
          selectedVersions.set(card.name, allVersions[0]);
        }
      }
      
      // If there are cards with multiple versions, show selection modal
      if (multipleVersions.length > 0) {
        await showVersionSelector(multipleVersions, selectedVersions);
      }
      
      // Generate deck list
      generateConvertedDeckList(selectedVersions);
    }

    async function getAllVersionsForCard(cardName) {
      const versions = [];
      
      // Check exact name match first
      if (collectionCards.has(cardName)) {
        versions.push(...collectionCards.get(cardName));
      }
      
      // Check for alternate names via Scryfall
      try {
        const response = await fetch(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(cardName)}`);
        if (!response.ok) return versions;
        const card = await response.json();
        
        // Check actual card name
        const actualName = card.name.toLowerCase();
        if (actualName !== cardName && collectionCards.has(actualName)) {
          versions.push(...collectionCards.get(actualName));
        }
        
        // Check flavor name
        if (card.flavor_name) {
          const flavorName = card.flavor_name.toLowerCase();
          if (collectionCards.has(flavorName)) {
            versions.push(...collectionCards.get(flavorName));
          }
        }
        
        // Check all printings for other flavor names
        const printingsResponse = await fetch(`https://api.scryfall.com/cards/search?q=!"${encodeURIComponent(card.name)}"&unique=prints`);
        if (printingsResponse.ok) {
          const printings = await printingsResponse.json();
          for (const printing of printings.data) {
            if (printing.flavor_name) {
              const flavorName = printing.flavor_name.toLowerCase();
              if (flavorName !== cardName && collectionCards.has(flavorName)) {
                versions.push(...collectionCards.get(flavorName));
              }
            }
          }
        }
      } catch (e) {
        console.error('Error fetching alternate names:', e);
      }
      
      return versions;
    }

    function showVersionSelector(multipleVersions, selectedVersions) {
      return new Promise(resolve => {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
          <div class="version-modal">
            <h2>Select Card Versions</h2>
            <p>You own multiple versions of these cards. Click to select which version to use:</p>
            <div class="version-list">
              ${multipleVersions.map((card, idx) => `
                <div class="version-group">
                  <div class="version-card-name">${card.quantity}x ${card.name.charAt(0).toUpperCase() + card.name.slice(1)}</div>
                  <div class="version-cards">
                    ${card.versions.map((v, vIdx) => `
                      <div class="version-card ${vIdx === 0 ? 'selected' : ''} ${v.foil !== 'normal' ? v.foil : ''}" 
                           data-card="${card.name}" 
                           data-version="${v.scryfallId}">
                        <div class="version-card-inner">
                          <img src="https://cards.scryfall.io/normal/front/${v.scryfallId[0]}/${v.scryfallId[1]}/${v.scryfallId}.jpg" 
                               alt="${card.name}" 
                               class="version-card-front"
                               onerror="this.src='images/back.png'">
                          <img src="images/back.png" alt="Card back" class="version-card-back">
                        </div>
                        <div class="version-info">
                          <div class="version-set">${v.setName}</div>
                          <div class="version-code">${v.setCode.toUpperCase()} #${v.collectorNumber}${v.foil !== 'normal' ? ' *' + v.foil.charAt(0).toUpperCase() + '*' : ''}</div>
                        </div>
                      </div>
                    `).join('')}
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="modal-actions">
              <button class="modal-btn confirm">Confirm Selection</button>
              <button class="modal-btn cancel">Cancel</button>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Add click handlers for version selection
        modal.querySelectorAll('.version-card').forEach(card => {
          card.addEventListener('click', () => {
            const cardName = card.dataset.card;
            modal.querySelectorAll(`.version-card[data-card="${CSS.escape(cardName)}"]`).forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
          });
          
          // Add 3D tilt effect
          const inner = card.querySelector('.version-card-inner');
          let isDragging = false;
          
          card.addEventListener('mousedown', e => {
            isDragging = true;
            e.preventDefault();
          });
          
          document.addEventListener('mouseup', () => {
            if (isDragging) {
              isDragging = false;
              inner.style.transform = '';
              inner.style.setProperty('--shimmer-x', '50%');
              inner.style.setProperty('--shimmer-y', '50%');
            }
          });
          
          card.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const rect = card.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width - 0.5;
            const y = (e.clientY - rect.top) / rect.height - 0.5;
            inner.style.transform = `rotateX(${-y * 15}deg) rotateY(${x * 15}deg)`;
            inner.style.setProperty('--shimmer-x', `${50 + x * 100}%`);
            inner.style.setProperty('--shimmer-y', `${50 + y * 100}%`);
          });
        });
        
        modal.querySelector('.confirm').addEventListener('click', () => {
          modal.querySelectorAll('.version-card.selected').forEach(card => {
            const cardName = card.dataset.card;
            const scryfallId = card.dataset.version;
            const versions = collectionCards.get(cardName);
            const selected = versions.find(v => v.scryfallId === scryfallId);
            selectedVersions.set(cardName, selected);
          });
          modal.remove();
          resolve();
        });
        
        modal.querySelector('.cancel').addEventListener('click', () => {
          modal.remove();
          resolve();
        });
      });
    }

    function generateConvertedDeckList(selectedVersions) {
      const output = [];
      const notConverted = [];
      
      for (const card of currentDeckList) {
        if (selectedVersions.has(card.name)) {
          const version = selectedVersions.get(card.name);
          const foilSuffix = version.foil !== 'normal' ? ` *${version.foil.charAt(0).toUpperCase()}*` : '';
          output.push(`${card.quantity} ${card.name.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')} (${version.setCode.toUpperCase()}) ${version.collectorNumber}${foilSuffix}`);
        } else {
          // Card not owned, add without version info
          output.push(`${card.quantity} ${card.name.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}`);
          notConverted.push(card.name);
        }
      }
      
      // Show result modal
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="result-modal">
          <h2>Converted Deck List</h2>
          ${notConverted.length > 0 ? `
            <div class="warning-box">
              <strong>‚ö† Not Converted (${notConverted.length} cards):</strong>
              <div class="not-converted-list">${notConverted.map(n => n.charAt(0).toUpperCase() + n.slice(1)).join(', ')}</div>
            </div>
          ` : ''}
          <textarea class="deck-output" readonly>${output.join('\n')}</textarea>
          <div class="modal-actions">
            <button class="modal-btn copy">Copy to Clipboard</button>
            <button class="modal-btn close">Close</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      const textarea = modal.querySelector('.deck-output');
      textarea.style.height = Math.min(400, textarea.scrollHeight) + 'px';
      
      modal.querySelector('.copy').addEventListener('click', () => {
        textarea.select();
        document.execCommand('copy');
        modal.querySelector('.copy').textContent = 'Copied!';
        setTimeout(() => modal.querySelector('.copy').textContent = 'Copy to Clipboard', 2000);
      });
      
      modal.querySelector('.close').addEventListener('click', () => modal.remove());
    }

    loadCollection();
  </script>
</body>
</html>
